//........................................
//.. https://stanbit.com smart contract ..
//........................................
pragma solidity ^0.4.25;
pragma experimental ABIEncoderV2;

//........................................
//........ libraries .....................
//........................................

//........................................
//........ SafeMath ......................
//........................................
library SafeMath {

  //........................................
  //.... Multiplies two numbers, ...........
  //.... throws on overflow ................
  //........................................
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }

  //........................................
  //..... Integer division of two numbers, .
  //..... truncating the quotient ..........
  //........................................
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  //........................................
  //..... Subtracts two numbers, ...........
  //..... throws on overflow (i.e. .........
  //..... if subtrahend is greater .........
  //..... than minuend) ....................
  //........................................
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  //........................................
  //..... Adds two numbers, throws .........
  //..... on overflow ......................
  //........................................
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}

//........................................
//........ modificators ..................
//........................................
contract Ownable {
    
    address public owner;
    
    constructor() public {
        owner = msg.sender;
    }
    
    //........................................
    //...... game actions: ...................
    //...... join, draw, signup, .............
    //...... leave, get commissions ..........
    //........................................
    modifier onlyGroup1() {
        if (
            msg.sender != 0xEf50b35f23ca70021db7b2Fb3CE63331e104DA82 &&
            msg.sender != 0xE5D6054C65154B23aEcBDACF7bd581ee88e629D3 &&
            msg.sender != 0xdB9b11e430293f06D5dD7FCc392a2537a7EA3eAF
        ) {
            revert();
        }
        _;
    }
    
    //........................................
    //..... only set commission and ..........
    //..... gas actions ......................
    //........................................
    modifier onlyGroup2() {
        if (
            msg.sender != 0x96EDcB0dD2f43cC4AF41D2052d21EE9Ec6eA8a39 &&
            msg.sender != 0x9535e8dcd490Baa514f7aB8a06116fb177759eD6 &&
            msg.sender != 0x4f6aC94FdED9AcD114ff08283326ca192AA6bD8B
        ) {
            revert();
        }
        _;
    }
    
    //........................................
    //...... ether actions ...................
    //...... withdraw, transfer, block .......
    //........................................
    modifier onlyGroup3() {
        if (
            msg.sender != 0xCfb028F62809f930C0a3C4BcE81EEF504Ac40df8 &&
            msg.sender != 0xB99511FFF8Fb8F77d80433Cb22234664eA16F25E &&
            msg.sender != 0x82fBc3E65caC73dBdCd2879f635f5524BB553182
        ) {
            revert();
        }
        _;
    }
}

//........................................
//...... main contract ...................
//...... https://stanbit.com .............
//........................................
contract Stanbit is Ownable{
    using SafeMath for uint;
    
    //...... the structure of the game .......
    //...... stores each element of ..........
    //...... which keeps the UID and .........
    //...... the list of players .............
    //........................................
    struct game {
        string[] players;
        string winner;
    }
    
    //........................................
    //...... public fields ..................
    //........................................
    uint public signupReferrerGas = 0;
    uint public transferGas = 0;
    uint public withdrawGas = 0;
    uint public leavePlayerGas = 0;
    uint public joinGas = 0;
    
    //........................................
    //...... private fields ..................
    //........................................
    uint private point;
    uint private nonce;
    uint private systemCommission = 10;
    uint private referrerCommission = 5;
    uint private systemCommissionAmount = 0;
    uint private referrerCommissionAmount = 0;
    
    //........................................
    //...... mappings ........................
    //........................................
    mapping(bytes => bytes32) private keys;
    mapping(bytes => bytes32) private joinKeys;
    mapping(bytes => bytes) private referrers;
    mapping(bytes => uint) private refProfit;
    mapping(bytes => uint) private balances;
    mapping(bytes => uint) private holds;
    mapping(string => game) private games;
    
    //.........................................
    //...... events ...........................
    //.........................................
    event NewCommission(uint systemCommission, uint referrerCommission);
    event PayIn(address from, bytes uid, uint amount);
    event PlayerJoin(string uid, string game_id, uint fee);
    event PlayerNumbers(string uid, uint index, uint fallbackNumber, uint joinNumber, uint gameNumber);
    event GameResult(string uid, uint profit, uint sum, uint playersCount, uint index);
    event Withdraw(address wallet, string uid, uint amount);
    
    //..........................................
    //...... contract constructor ..............
    //...... init point and increase nonce .....
    //..........................................
    constructor(uint _point) public {
        point = _point;
        nonce++;
    }
    
    //........................................
    //...... draw function ...................
    //...... args: ...........................
    //......... fee – cost of participation ..
    //......... gid – uniq game ID ...........
    //......... uids – array of the players ..
    //........................................
    function draw(uint _fee, string memory _gid, string[] memory _uids) payable onlyGroup1 public {
        uint sum = 0;
        uint i = 0;
        for (i = 0; i < _uids.length; i++) {
            if (holds[bytes(_uids[i])] < _fee) {
                revert();
            }
        }
        for (i = 0; i < _uids.length; i++) {
            uint fallbackNumber = uint(keys[bytes(_uids[i])]);
            uint joinNumber = uint(joinKeys[bytes(_uids[i])]);
            uint gameNumber = (fallbackNumber + joinNumber + gasleft() + (block.number % nonce++)) % point;
            emit PlayerNumbers(_uids[i], i, fallbackNumber, joinNumber, gameNumber);
            sum = sum.add(gameNumber).mul(i);
            balances[bytes(_uids[i])] = balances[bytes(_uids[i])].sub(_fee);
            holds[bytes(_uids[i])] = holds[bytes(_uids[i])].sub(_fee);
        }
        uint index = uint(sum % _uids.length);
        uint balance = _fee.mul(_uids.length);
        uint systemPercent = balance.div(100).mul(systemCommission);
        uint profit = balance.sub(systemPercent);
        systemCommissionAmount = systemCommissionAmount.add(systemPercent);
        balances[bytes(_uids[index])] = balances[bytes(_uids[index])].add(profit);
        games[_gid].winner = _uids[index];
        if (referrers[bytes(_uids[index])].length > 0) {
            uint referrerPercent = balance.div(100).mul(referrerCommission);
            referrerPercent = referrerPercent.sub(tx.gasprice * transferGas);
            referrerCommissionAmount = referrerCommissionAmount.add(referrerPercent);
            systemCommissionAmount = systemCommissionAmount.sub(referrerPercent);
            balances[referrers[bytes(_uids[index])]] = 
                balances[referrers[bytes(_uids[index])]].add(referrerPercent);
            refProfit[bytes(_uids[index])] = refProfit[bytes(_uids[index])].add(referrerPercent);
        }
        emit GameResult(_uids[index], balance, sum, _uids.length, index);
    }
    
    //........................................
    //...... signupReferrer function .........
    //...... args: ...........................
    //......... uid – uniw player ID .........
    //......... referrer – ID of refferer ....
    //......... if exists ....................
    //........................................
    function signupReferrer(string memory _uid, string memory _referrer, uint _amount) onlyGroup1 public {
        nonce++;
        referrers[bytes(_referrer)] = bytes(_uid);
        _amount = _amount.sub(tx.gasprice * signupReferrerGas);
        refProfit[bytes(_uid)] = refProfit[bytes(_uid)].add(_amount);
        balances[bytes(_uid)] = balances[bytes(_uid)].add(_amount);
        referrerCommissionAmount = referrerCommissionAmount.add(_amount);
        systemCommissionAmount = systemCommissionAmount.sub(_amount);
    }
    
    //........................................
    //...... join function ...................
    //...... args: ...........................
    //......... fee – cost of participation ..
    //......... uid – uniq user ID ...........
    //......... gid – uniw game ID ...........
    //........................................
    function join(uint _fee, string memory _uid, string memory _gid) onlyGroup1 public {
        nonce++;
        uint com = tx.gasprice * joinGas;
        if (balances[bytes(_uid)] < _fee + com) {
            revert();
        }
        uint i = 0;
        for (i = 0; i < games[_gid].players.length; i++) {
            if (keccak256(abi.encodePacked(games[_gid].players[i])) == keccak256(abi.encodePacked(_uid))) {
                revert();
            }
        }
        balances[bytes(_uid)] = balances[bytes(_uid)].sub(com);
        systemCommissionAmount = systemCommissionAmount.add(com);
        holds[bytes(_uid)] = holds[bytes(_uid)].add(_fee);
        games[_gid].players.push(_uid);
        bytes32 salt = keccak256(abi.encodePacked(nonce, now, _gid, blockhash(block.number)));
        joinKeys[bytes(_uid)] = keccak256(abi.encodePacked(gasleft() + nonce, _gid, salt));
        emit PlayerJoin(_uid, _gid, _fee);
    }
    
    //........................................
    //...... set commission function .........
    //........................................
    function setCommission(uint _systemCommission, uint _referrerCommission) onlyGroup2 public {
        systemCommission = _systemCommission;
        referrerCommission = _referrerCommission;
        nonce++;
        emit NewCommission(systemCommission, referrerCommission);
    }
    
    //........................................
    //...... withdraw function ...............
    //...... args: ...........................
    //......... amount – amount in wei .......
    //......... to – wallet address ..........
    //......... uid – uniq user ID ...........
    //........................................
    function withdraw(uint _amount, address _to, string memory _uid) payable onlyGroup3 public {
        nonce++;
        if (_to == owner) {
            systemCommissionAmount = systemCommissionAmount.sub(_amount);
            _to.transfer(_amount);
        } else {
            if (_amount > balances[bytes(_uid)].sub(holds[bytes(_uid)])) {
                revert();
            }
    	    balances[bytes(_uid)] = balances[bytes(_uid)].sub(_amount);
    	    uint com = tx.gasprice * withdrawGas;
    	    _amount = _amount.sub(com);
    	    systemCommissionAmount = systemCommissionAmount.add(com);
            _to.transfer(_amount);
            emit Withdraw(_to, _uid, _amount);
        }
    }
    
    //........................................
    //...... transferTo function .............
    //...... args: ...........................
    //......... from – uniq user ID ..........
    //......... to – uniq user ID ............
    //......... amount – amount in wei .......
    //........................................
    function transferTo(string memory _from, string memory _to, uint _amount) onlyGroup3 public {
        if (balances[bytes(_from)] < _amount) {
            revert();
        }
        balances[bytes(_from)] = balances[bytes(_from)].sub(_amount);
        balances[bytes(_to)] = balances[bytes(_to)].add(_amount);
    }
    
    //........................................
    //...... checkPLayer function ............
    //...... args: ...........................
    //......... gid – uniq game ID ...........
    //......... uid – uniq user ID ...........
    //........................................
    function checkPlayer(string memory _gid, string memory _uid) public view returns(bool result) {
        uint i = 0;
        for (i = 0; i < games[_gid].players.length; i++) {
            if (keccak256(abi.encodePacked(games[_gid].players[i])) == keccak256(abi.encodePacked(_uid))) {
                return true;
            }
        }
        return false;
    }
    
    //........................................
    //...... getWinner function ..............
    //...... args: ...........................
    //......... gid – uniq game ID ...........
    //........................................
    function getWinner(string memory _gid) public view returns (string memory winner) {
        return games[_gid].winner;
    }
    
    //........................................
    //...... balanceOf function ..............
    //...... args: ...........................
    //......... uid – uniq user ID ...........
    //........................................
    function balanceOf(string memory _uid) public view returns (uint total, uint hold) {
        return (balances[bytes(_uid)], holds[bytes(_uid)]);
    }
    
    //........................................
    //...... getRefProfit function ...........
    //...... args: ...........................
    //......... uid – uniq user ID ...........
    //........................................
    function getRefProfit(string memory _uid) public view returns (uint profit) {
        return refProfit[bytes(_uid)];
    }
    
    //........................................
    //...... leave function ..................
    //...... args: ...........................
    //......... uid – uniq user ID ...........
    //......... fee – cost of participation ..
    //........................................
    function leavePlayer(string memory _uid, uint _fee) onlyGroup1 public {
        if (holds[bytes(_uid)] < _fee) {
            revert();
        }
        uint com = tx.gasprice * leavePlayerGas;
        balances[bytes(_uid)] = balances[bytes(_uid)].sub(com);
        systemCommissionAmount = systemCommissionAmount.add(com);
        holds[bytes(_uid)] = holds[bytes(_uid)].sub(_fee);
    }
    
    //........................................
    //...... block function ..................
    //...... args: ...........................
    //......... uid – uniq user ID ...........
    //........................................
    function blockPlayer(string memory _uid) onlyGroup3 public {
        systemCommissionAmount = systemCommissionAmount.add(balances[bytes(_uid)]);
        balances[bytes(_uid)] = 0;
    }
    
    //........................................
    //...... getCommissions function .........
    //...... returns system and referrer .....
    //...... commissions .....................
    //........................................
    function getCommissions() public view returns (uint sys, uint ref) {
        if (msg.sender == 0xEf50b35f23ca70021db7b2Fb3CE63331e104DA82) {
            return (systemCommissionAmount, referrerCommissionAmount);
        } else {
            return (0, 0);
        }
    }
    
    //........................................
    //...... set gas counts for signup .......
    //........................................
    function setSignupReferrerGas(uint _value) onlyGroup2 public {
        signupReferrerGas = _value;
    }
    
    //........................................
    //...... set gas counts for transfer .....
    //........................................
    function setTransferGas(uint _value) onlyGroup2 public {
        transferGas = _value;
    }
    
    //........................................
    //...... set gas counts for withdraw .....
    //........................................
    function setWithdrawGas(uint _value) onlyGroup2 public {
        withdrawGas = _value;
    }
    
    //........................................
    //...... set gas counts for leave ........
    //........................................
    function setLeavePlayerGas(uint _value) onlyGroup2 public {
        leavePlayerGas = _value;
    }
    
    //........................................
    //...... set gas counts for join .........
    //........................................
    function setJoinGas(uint _value) onlyGroup2 public {
        joinGas = _value;
    }
    
    //........................................
    //...... fallback function ...............
    //........................................
    function () external payable {
        if (msg.value < 100000000000000000) {
            revert();
        }
        nonce++;
        bytes32 salt = keccak256(abi.encodePacked(gasleft(), now, nonce, blockhash(block.number)));
        keys[msg.data] = keccak256(abi.encodePacked(msg.value, msg.sender, salt));
        balances[msg.data] = balances[msg.data].add(msg.value);
        emit PayIn(msg.sender, msg.data, msg.value);
    }
}
